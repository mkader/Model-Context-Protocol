* Clients are custom applications or scripts that communicate directly with an MCP Server to request resources, tools, and prompts. 
* Unlike using the inspector tool, which provides a graphical interface for interacting with the server, writing your own client allows for programmatic and automated interactions. 
* This enables developers to integrate MCP capabilities into their own workflows, automate tasks, and build custom solutions tailored to specific needs.

* To write a client, you'll need to do the following:
    - **Import the correct libraries**. You'll be using the same library as before, just different constructs.
    - **Instantiate a client**. This will involve creating a client instance and connect it to the chosen transport method.
    - **Decide on what resources to list**. Your MCP server comes with resources, tools and prompts, you need to decide which one to list.
    - **Integrate the client to a host application**. Once you know the capabilities of the server you need to integrate this your host application so that if a user types a prompt or other command the corresponding server feature is invoked.

#### Typescript
* 1.Import the libraries
  ```
  import { Client } from "@modelcontextprotocol/sdk/client/index.js";
  import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
  ```

* 2.Instantiating client and transport
    - stdio is a protocol for things meant to run on your local machine. 
    - SSE is another transport protocol
  ```
  // Created an stdio transport instance. 
  //Note how it specifies command and args for how to find and start up the server
  const transport = new StdioClientTransport({
      command: "node",
      args: ["server.js"]
  });
  
  // Instantiated a client by giving it a name and version.
  const client = new Client(
  {
      name: "example-client",
      version: "1.0.0"
  });
  
  //Connected the client to the chosen transport.
  await client.connect(transport);
  ```

* 3.Listing the server features
  ```
  // List prompts
  const prompts = await client.listPrompts();

  // List resources
  const resources = await client.listResources();

  // list tools
  const tools = await client.listTools();
  ```

* 4.Invoke features - specify the correct arguments and in some cases the name
    ```
    // Read a resource
    const resource = await client.readResource({
      uri: "file:///example.txt"
    });
    ```

    - Read a resource `readResource()` specifying `uri`. On the server side:
    - `uri` value `file://example.txt` matches `file://{name}` on the server. `example.txt` will be mapped to `name`.
    ```
    server.resource(
        "readFile",
        new ResourceTemplate("file://{name}", { list: undefined }),
        async (uri, { name }) => ({
          contents: [{
            uri: uri.href,
            text: `Hello, ${name}!`
          }]
        })
    );
    ```
    ```
    // Call a tool
    const result = await client.callTool({
      name: "example-tool",
      arguments: {
        arg1: "value"
      }
    });
    ```

    ```
    // call prompt
    const promptResult = await client.getPrompt({
        name: "review-code",
        arguments: {
            code: "console.log(\"Hello world\")"
        }
    })
    ```
    - call `getPrompt()` with `name` and `arguments`. On the server code looks like so:
    ```
    server.prompt(
        "review-code",
        { code: z.string() },
        ({ code }) => ({
            messages: [{
            role: "user",
            content: {
                type: "text",
                text: `Please review this code:\n\n${code}`
            }
            }]
        })
    );
    ```

    - 5.Run the client
    ```
    //Add the following entry to your "scripts" section in *package.json*:
    "client": "tsc && node build/client.js"

    npm run client
    ```

#### Python
  ```
  //1.Import the libraries
  from mcp import ClientSession, StdioServerParameters, types
  from mcp.client.stdio import stdio_client
  
  //2.Instantiating client and transport
  # Create server parameters for stdio connection
  server_params = StdioServerParameters(
      command="mcp",  # Executable
      args=["run", "server.py"],  # Optional command line arguments
      env=None,  # Optional environment variables
  )
  
  //`run` method calls `stdio_client` which starts a client session.
  async def run():
      async with stdio_client(server_params) as (read, write):
          async with ClientSession(
              read, write
          ) as session:
              # Initialize the connection
              await session.initialize()
  
  //Created an entry point where we provide the `run` method to `asyncio.run`.
  if __name__ == "__main__":
      import asyncio
  
      asyncio.run(run())


  //3. Listing the server features
  # List available resources
  resources = await session.list_resources()
  print("LISTING RESOURCES")
  for resource in resources:
      print("Resource: ", resource)

  # List available tools
  tools = await session.list_tools()
  print("LISTING TOOLS")
  for tool in tools.tools:
      print("Tool: ", tool.name)


//4.Invoke features - specify the correct arguments and in some cases the name
  # Read a resource
  print("READING RESOURCE")
  content, mime_type = await session.read_resource("greeting://hello")

  # Call a tool
  print("CALL TOOL")
  result = await session.call_tool("add", arguments={"a": 1, "b": 7})
  print(result.content)

 //5.Run the client
 python client.py
```

#### .NET
```
  //1.Import the libraries
  using Microsoft.Extensions.AI;
  using Microsoft.Extensions.Configuration;
  using Microsoft.Extensions.Hosting;
  using ModelContextProtocol.Client;
  using ModelContextProtocol.Protocol.Transport;
  
  var builder = Host.CreateApplicationBuilder(args);
  
  builder.Configuration
      .AddEnvironmentVariables()
      .AddUserSecrets<Program>();
  
  //2.Instantiating client and transport
  //Create an stdio transport
  // "Arguments" - you can either point to the *.csproj* or to the executable.
  var clientTransport = new StdioClientTransport(new()
  {
      Name = "Demo Server",
      Command = "dotnet",
      Arguments = ["run", "--project", "path/to/file.csproj"],
  });
  
  //created a client `mcpClient`
  await using var mcpClient = await McpClientFactory.CreateAsync(clientTransport);

  //3.Listing the server features
  foreach (var tool in await client.ListToolsAsync())
  {
      Console.WriteLine($"{tool.Name} ({tool.Description})");
  }

  //4.Invoke features - specify the correct arguments and in some cases the name
  // call a tool:
  var result = await mcpClient.CallToolAsync(
      "Add",
      new Dictionary<string, object?>() { ["a"] = 1, ["b"] = 3  },
      cancellationToken:CancellationToken.None);
   
  //To print out the result
  Console.WriteLine(result.Content.First(c => c.Type == "text").Text);

  //5.Run the client
  dotnet run
  ```

#### Solution Structure
```text
solution/
├── typescript/          # TypeScript client with npm/Node.js setup
│   ├── package.json     # Dependencies and scripts
│   ├── tsconfig.json    # TypeScript configuration
│   └── src/             # Source code
├── python/              # Python client implementation
│   ├── client.py        # Main client code
│   ├── server.py        # Compatible server
│   └── README.md        # Python-specific instructions
├── dotnet/              # .NET client project
│   ├── dotnet.csproj    # Project configuration
│   ├── Program.cs       # Main client code
│   └── dotnet.sln       # Solution file
└── server/              # Additional .NET server implementation
    ├── Program.cs       # Server code
    └── server.csproj    # Server project file
```
