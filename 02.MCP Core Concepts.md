### MCP Architecture: A Deeper Look
  * The MCP ecosystem is built on a client-server model.
  * This modular structure allows AI applications to interact with tools, databases, APIs, and contextual resources efficiently.
  * The MCP Protocol is an evolving date-based versioning (YYYY-MM-DD). The current version is **2025-06-18**. [protocol specification](https://modelcontextprotocol.io/specification/2025-06-18/)
  * Let's break down this architecture into its core components, MCP follows a client-server architecture where a host application can connect to multiple servers:
    - **MCP Hosts**: Programs like VSCode, IDEs, or AI tools that want to access data through MCP
    - **MCP Clients**: Protocol clients that maintain 1:1 connections with servers
    - **MCP Servers**: Lightweight programs that each expose specific capabilities through the standardized MCP
    - **Local Data Sources**: Your computer's files, databases, and services that MCP servers can securely access
    - **Remote Services**: External systems available over the internet that MCP servers can connect to through APIs.

| <img width="450" height="300" alt="image" src="https://github.com/user-attachments/assets/1eb068e3-e1d5-439c-b562-f3976c0a1e8a" /> | <img width="500" height="250" alt="image" src="https://github.com/user-attachments/assets/a7557680-9a9a-4988-991b-bb5f4638a2d0" /> |
|------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|

### 1. Hosts
  * **Hosts** are AI applications that serve as the primary interface through which users interact with the protocol.
  * Hosts coordinate and manage connections to multiple MCP servers by creating dedicated MCP clients for each server connection.
  * Examples of Hosts include:
    - **AI Applications**: Claude Desktop, Visual Studio Code, Claude Code
    - **Development Environments**: IDEs and code editors with MCP integration  
    - **Custom Applications**: Purpose-built AI agents and tools
  * **Hosts** are applications that coordinate AI model interactions. They:
    - **Orchestrate AI Models**: Execute or interact with LLMs to generate responses and coordinate AI workflows
    - **Manage Client Connections**: Create and maintain one MCP client per MCP server connection
    - **Control User Interface**: Handle conversation flow, user interactions, and response presentation  
    - **Enforce Security**: Control permissions, security constraints, and authentication
    - **Handle User Consent**: Manage user approval for data sharing and tool execution

### 2. Clients
  * **Clients** are essential components that maintain dedicated 1-to-1 connections between Hosts and MCP servers.
  * Each MCP client is instantiated by the Host to connect to a specific MCP server, ensuring organized and secure communication channels.
  * Multiple clients enable Hosts to connect to multiple servers simultaneously.
  * **Clients** are connector components within the host application. They:
    - **Protocol Communication**: Send JSON-RPC 2.0 requests to servers with prompts and instructions
    - **Capability Negotiation**: Negotiate supported features and protocol versions with servers during initialization
    - **Tool Execution**: Manage tool execution requests from models and process responses
    - **Real-time Updates**: Handle notifications and real-time updates from servers
    - **Response Processing**: Process and format server responses for display to users

### 3. Servers
  * **Servers** are programs that provide context, tools, and capabilities to MCP clients.
  * They can execute locally (same machine) or remotely (on external platforms) and are responsible for handling client requests and providing structured responses.
  * Servers expose specific functionality through the standardized MCP.
  * **Servers** are services that provide context and capabilities. They:
    - **Feature Registration**: Register and expose available primitives (resources, prompts, tools) to clients
    - **Request Processing**: Receive and execute tool calls, resource requests, and prompt requests from clients
    - **Context Provision**: Provide contextual information and data to enhance model responses
    - **State Management**: Maintain session state and handle stateful interactions when needed
    - **Real-time Notifications**: Send notifications about capability changes and updates to connected clients
  
<img width="450" height="250" alt="image" src="https://github.com/user-attachments/assets/f0c785c9-bb3a-416f-b3f7-e40f0b9c6f9f" />

### 4. Server Primitives
  * Servers in the MCP provide 3 core **primitives** that define the fundamental building blocks for rich interactions between clients, hosts, and language models.
  * These primitives specify the types of contextual information and actions available through the protocol.
  * MCP servers can expose any combination of the following three core primitives:
  * 1.**Resources**
    * **Resources** are data sources that provide contextual information to AI applications.
    * They represent static or dynamic content that can enhance model understanding and decision-making:
      - **Contextual Data**: Structured information and context for AI model consumption
      - **Knowledge Bases**: Document repositories, articles, manuals, and research papers
      - **Local Data Sources**: Files, databases, and local system information  
      - **External Data**: API responses, web services, and remote system data
      - **Dynamic Content**: Real-time data that updates based on external conditions
    * Resources are identified by URIs and support discovery through `resources/list` and retrieval through `resources/read` methods:
      ```text
      file://documents/project-spec.md
      database://production/users/schema
      api://weather/current
      ```

  * 2.**Prompts**
    * **Prompts** are reusable templates that help structure interactions with language models.
    * They provide standardized interaction patterns and templated workflows:
      - **Template-based Interactions**: Pre-structured messages and conversation starters
      - **Workflow Templates**: Standardized sequences for common tasks and interactions
      - **Few-shot Examples**: Example-based templates for model instruction
      - **System Prompts**: Foundational prompts that define model behavior and context
      - **Dynamic Templates**: Parameterized prompts that adapt to specific contexts
    * Prompts support variable substitution and can be discovered via `prompts/list` and retrieved with `prompts/get`:
      ```markdown
      Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
      ```
  
  * 3.**Tools**
    * **Tools** are executable functions that AI models can invoke to perform specific actions.
    * They represent the "verbs" of the MCP ecosystem, enabling models to interact with external systems:
      - **Executable Functions**: Discrete operations that models can invoke with specific parameters
      - **External System Integration**: API calls, database queries, file operations, calculations
      - **Unique Identity**: Each tool has a distinct name, description, and parameter schema
      - **Structured I/O**: Tools accept validated parameters and return structured, typed responses
      - **Action Capabilities**: Enable models to perform real-world actions and retrieve live data
    * Tools are defined with JSON Schema for parameter validation and discovered through `tools/list` and executed via `tools/call`:
      ```typescript
      server.tool(
        "search_products", 
        {
          query: z.string().describe("Search query for products"),
          category: z.string().optional().describe("Product category filter"),
          max_results: z.number().default(10).describe("Maximum results to return")
        }, 
        async (params) => {
          // Execute search and return structured results
          return await productService.search(params);
        }
      );
      ```

### Client Primitives
  * **clients** can expose primitives that enable servers to request additional capabilities from the host application.
  * These client-side primitives allow for richer, more interactive server implementations that can access AI model capabilities and user interactions.
  * 1.**Sampling** - allows servers to request language model completions from the client's AI application.
      - **Model-Independent Access**: Servers can request completions without including LLM SDKs or managing model access
      - **Server-Initiated AI**: Enables servers to autonomously generate content using the client's AI model
      - **Recursive LLM Interactions**: Supports complex scenarios where servers need AI assistance for processing
      - **Dynamic Content Generation**: Allows servers to create contextual responses using the host's model
    * Sampling is initiated through the `sampling/complete` method, where servers send completion requests to clients.
  * 2.**Elicitation** - enables servers to request additional information or confirmation from users through the client interface:
      - **User Input Requests**: Servers can ask for additional information when needed for tool execution
      - **Confirmation Dialogs**: Request user approval for sensitive or impactful operations
      - **Interactive Workflows**: Enable servers to create step-by-step user interactions
      - **Dynamic Parameter Collection**: Gather missing or optional parameters during tool execution
    * Elicitation requests are made using the `elicitation/request` method to collect user input through the client's interface.
  * 3.**Logging** - allows servers to send structured log messages to clients for debugging, monitoring, and operational visibility:


### Information Flow in MCP  
  * The MCP defines a structured flow of information between hosts, clients, servers, and models.
  * Understanding this flow helps clarify how user requests are processed and how external tools and data are integrated into model responses.
    1. **Host Initiates Connection** - The host application (such as an IDE or chat interface) establishes a connection to an MCP server, typically via STDIO, WebSocket, or another supported transport.
    2. **Capability Negotiation**  
        * The client (embedded in the host) and the server exchange information about their supported features, tools, resources, and protocol versions.
        * This ensures both sides understand what capabilities are available for the session.
    3. **User Request** - The user interacts with the host (e.g., enters a prompt or command). The host collects this input and passes it to the client for processing.
    4. **Resource or Tool Use**  
        - The client may request additional context or resources from the server (such as files, database entries, or knowledge base articles) to enrich the model's understanding.
        - If the model determines that a tool is needed (e.g., to fetch data, perform a calculation, or call an API), the client sends a tool invocation request to the server, specifying the tool name and parameters.
    5. **Server Execution** - The server receives the resource or tool request, executes the necessary operations (such as running a function, querying a database, or retrieving a file), and returns the results to the client in a structured format.
     6. **Response Generation** - The client integrates the server's responses (resource data, tool outputs, etc.) into the ongoing model interaction. The model uses this information to generate a comprehensive and contextually relevant response.
     7. **Result Presentation** - The host receives the final output from the client and presents it to the user, often including both the model's generated text and any results from tool executions or resource lookups.
<img width="400" height="250" alt="image" src="https://github.com/user-attachments/assets/a3967be0-bbaa-4e90-b93c-2730f020b660" />

### Protocol Architecture & Layers
  * MCP consists of 3 distinct architectural layers
  1. Data Layer - defines the message structure, semantics, and interaction patterns:
      * Core Components:
          - **JSON-RPC 2.0 Protocol**: All communication uses JSON-RPC 2.0 message format for method calls, responses, and notifications
          - **Lifecycle Management**: Handles connection initialization, capability negotiation, and session termination between clients and servers
          - **Server Primitives**: Enables servers to provide core functionality through tools, resources, and prompts
          - **Client Primitives**: Enables servers to request sampling from LLMs, elicit user input, and send log messages
          - **Real-time Notifications**: Supports asynchronous notifications for dynamic updates without polling
      * Key Features:
          - **Protocol Version Negotiation**: Uses date-based versioning (YYYY-MM-DD) to ensure compatibility
          - **Capability Discovery**: Clients and servers exchange supported feature information during initialization
          - **Stateful Sessions**: Maintains connection state across multiple interactions for context continuity
  3. Transport Layer - manages communication channels, message framing, and authentication between MCP participants:
      1. **STDIO Transport** - Uses standard input/output streams for direct process communication. Commonly used for local MCP server implementations
      2. **Streamable HTTP Transport**:
         - Uses HTTP POST for client-to-server messages  
         - Optional Server-Sent Events (SSE) for server-to-client streaming
         - Enables remote server communication across networks
         - Supports standard HTTP authentication (bearer tokens, API keys, custom headers)
         - MCP recommends OAuth for secure token-based authentication
 
### Code Example
 * .NET Example: Creating a Simple MCP Server with Tools - https://github.com/mkader/Model-Context-Protocol/blob/main/02_0.program.cs

## Security and Authorization
1. **Tool Permission Control**:
   * Clients can specify which tools a model is allowed to use during a session.
   * This ensures that only explicitly authorized tools are accessible, reducing the risk of unintended or unsafe operations.
   * Permissions can be configured dynamically based on user preferences, organizational policies, or the context of the interaction.

2. **Authentication**:  
   * Servers can require authentication before granting access to tools, resources, or sensitive operations.
   * This may involve API keys, OAuth tokens, or other authentication schemes.
   * Proper authentication ensures that only trusted clients and users can invoke server-side capabilities.

3. **Validation**:  
   * Parameter validation is enforced for all tool invocations.
   * Each tool defines the expected types, formats, and constraints for its parameters, and the server validates incoming requests accordingly.
   * This prevents malformed or malicious input from reaching tool implementations and helps maintain the integrity of operations.

4. **Rate Limiting**:  
   * To prevent abuse and ensure fair usage of server resources, MCP servers can implement rate limiting for tool calls and resource access.
   * Rate limits can be applied per user, per session, or globally, and help protect against denial-of-service attacks or excessive resource consumption.

### Protocol Messages & Communication Flow
 * MCP communication uses **JSON-RPC 2.0** messages to facilitate clear and reliable interactions between hosts, clients, and servers.
 * The protocol defines specific message patterns for different types of operations:
 * Core Message Types:
   1. **Initialization Messages**
      - **`initialize` Request**: Establishes connection and negotiates protocol version and capabilities
      - **`initialize` Response**: Confirms supported features and server information  
      - **`notifications/initialized`**: Signals that initialization is complete and the session is ready

   2. **Discovery Messages**
      - **`tools/list` Request**: Discovers available tools from the server
      - **`resources/list` Request**: Lists available resources (data sources)
      - **`prompts/list` Request**: Retrieves available prompt templates

   3. **Execution Messages**  
      - **`tools/call` Request**: Executes a specific tool with provided parameters
      - **`resources/read` Request**: Retrieves content from a specific resource
      - **`prompts/get` Request**: Fetches a prompt template with optional parameters

   4. **Client-side Messages**
      - **`sampling/complete` Request**: Server requests LLM completion from the client
      - **`elicitation/request`**: Server requests user input through the client interface
      - **Logging Messages**: Server sends structured log messages to the client

   5. **Notification Messages**
      - **`notifications/tools/list_changed`**: Server notifies client of tool changes
      - **`notifications/resources/list_changed`**: Server notifies client of resource changes  
      - **`notifications/prompts/list_changed`**: Server notifies client of prompt changes

   6. Message Structure - All MCP messages follow JSON-RPC 2.0 format with:
      - **Request Messages**: Include `id`, `method`, and optional `params`
      - **Response Messages**: Include `id` and either `result` or `error`  
      - **Notification Messages**: Include `method` and optional `params` (no `id` or response expected)
